"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _classNode, _referencer, _emitDecoratorMetadata;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassVisitor = void 0;
const types_1 = require("@typescript-eslint/types");
const definition_1 = require("../definition");
const TypeVisitor_1 = require("./TypeVisitor");
const Visitor_1 = require("./Visitor");
class ClassVisitor extends Visitor_1.Visitor {
    constructor(referencer, node, emitDecoratorMetadata) {
        super(referencer);
        _classNode.set(this, void 0);
        _referencer.set(this, void 0);
        _emitDecoratorMetadata.set(this, void 0);
        __classPrivateFieldSet(this, _referencer, referencer);
        __classPrivateFieldSet(this, _classNode, node);
        __classPrivateFieldSet(this, _emitDecoratorMetadata, emitDecoratorMetadata);
    }
    static visit(referencer, node, emitDecoratorMetadata) {
        const classVisitor = new ClassVisitor(referencer, node, emitDecoratorMetadata);
        classVisitor.visitClass(node);
    }
    visit(node) {
        // make sure we only handle the nodes we are designed to handle
        if (node && node.type in this) {
            super.visit(node);
        }
        else {
            __classPrivateFieldGet(this, _referencer).visit(node);
        }
    }
    ///////////////////
    // Visit helpers //
    ///////////////////
    visitClass(node) {
        var _a, _b;
        if (node.type === types_1.AST_NODE_TYPES.ClassDeclaration && node.id) {
            __classPrivateFieldGet(this, _referencer).currentScope()
                .defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));
        }
        (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _referencer).visit(d));
        __classPrivateFieldGet(this, _referencer).scopeManager.nestClassScope(node);
        if (node.id) {
            // define the class name again inside the new scope
            // references to the class sh