/**
 * @fileoverview Utility class and functions for React components detection
 * @author Yannick Croissant
 */

'use strict';

const doctrine = require('doctrine');
const arrayIncludes = require('array-includes');
const values = require('object.values');

const variableUtil = require('./variable');
const pragmaUtil = require('./pragma');
const astUtil = require('./ast');
const propTypesUtil = require('./propTypes');
const jsxUtil = require('./jsx');
const usedPropTypesUtil = require('./usedPropTypes');
const defaultPropsUtil = require('./defaultProps');
const isFirstLetterCapitalized = require('./isFirstLetterCapitalized');

function getId(node) {
  return node && node.range.join(':');
}

function usedPropTypesAreEquivalent(propA, propB) {
  if (propA.name === propB.name) {
    if (!propA.allNames && !propB.allNames) {
      return true;
    }
    if (Array.isArray(propA.allNames) && Array.isArray(propB.allNames) && propA.allNames.join('') === propB.allNames.join('')) {
      return true;
    }
    return false;
  }
  return false;
}

function mergeUsedPropTypes(propsList, newPropsList) {
  const propsToAdd = [];
  newPropsList.forEach((newProp) => {
    const newPropisAlreadyInTheList = propsList.some((prop) => usedPropTypesAreEquivalent(prop, newProp));
    if (!newPropisAlreadyInTheList) {
      propsToAdd.push(newProp);
    }
  });

  return propsList.concat(propsToAdd);
}

function isReturnsConditionalJSX(node, property, strict) {
  const returnsConditionalJSXConsequent = node[property]
    && node[property].type === 'ConditionalExpression'
    && jsxUtil.isJSX(node[property].consequent);
  const returnsConditionalJSXAlternate = node[property]
    && node[property].type === 'ConditionalExpression'
    && jsxUtil.isJSX(node[property].alternate);
  return strict
    ? (returnsConditionalJSXConsequent && returnsConditionalJSXAlternate)
    : (returnsConditionalJSXConsequent || returnsConditionalJSXAlternate);
}

function isReturnsLogicalJSX(node, property, strict) {
  const returnsLogicalJSXLeft = node[property]
    && node[property].type === 'LogicalExpression'
    && jsxUtil.isJSX(node[property].left);
  const returnsLogicalJSXRight = node[property]
    && node[property].type === 'LogicalExpression'
    && jsxUtil.isJSX(node[property].right);
  return strict
    ? (returnsLogicalJSXLeft && returnsLogicalJSXRight)
    : (returnsLogicalJSXLeft || returnsLogicalJSXRight);
}

function isReturnsSequentialJSX(node, property) {
  return node[property]
    && node[property].type === 'SequenceExpression'
    && jsxUti